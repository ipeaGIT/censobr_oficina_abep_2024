[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{censobr}: Explorando o Censo Demográfico em R",
    "section": "",
    "text": "1 Introdução\nEste site apresenta o material de apoio para a oficina “{censobr}: Explorando o Censo Demográfico em R”. A oficina será realizada como parte da programação do 23o Encontro da ABEP, em Brasília, entre os dias 23 e 26 de setembro de 2024.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "index.html#bio-dos-instrutors",
    "href": "index.html#bio-dos-instrutors",
    "title": "{censobr}: Explorando o Censo Demográfico em R",
    "section": "4.1 Bio dos instrutors:",
    "text": "4.1 Bio dos instrutors:\nRafael H. M. Pereira é pesquisador sênior nas áreas de planejamento urbano, ciência de dados espaciais e mobilidade urbana no Instituto de Pesquisa Econômica Aplicada (Ipea). Sua pesquisa investiga como as políticas urbanas e tecnologias moldam a organização espacial das cidades, a mobilidade humana, bem como seus impactos nas desigualdades sociais e de saúde. Algumas de suas contribuições nos campos de urban analytics e planejamento envolvem o desenvolvimento de novos métodos e ferramentas computacionais de código aberto para o estudo de sistemas urbanos e redes de transporte. Essas contribuições partem de interesses substantivos sobre questões de equidade no planejamento urbano, desigualdades de acesso a oportunidades, e dos impactos ambientais do ambiente construído e de padrões de mobilidade. Com graduação em sociologia pela UnB e mestrado em demografia pela Unicamp, Rafael Pereira obteve seu PhD em geografia pela Universidade de Oxford.\nRogério Barbosa é Professor de Sociologia do Instituto de Estudos Sociais e Políticos (IESP) da Universidade do Estado do Rio de Janeiro (UERJ), atuando nas áreas de Métodos Quantitativos e Estratificação Social. Formou-se bacharel em Ciências Sociais pela UFMG, mestre e doutor em Sociologia pela Universidade de São Paulo (2017). Realizou estágio pos-doutoral em Ciência Política pela USP e foi visiting scholar no Departamento de Sociologia da Columbia University. É pesquisador associado do Centro de Estudos da Metrópole (CEM-USP), affiliated scholar no Brazil Lad da Princeton University e membro da Rede de Pesquisa Solidária Políticas Públicas e Sociedade. Trabalhou como consultor metodológico de diversos grupos de pesquisa e também ministrou diversos cursos de programação e métodos estatísticos para instituições e universidades no Brasil. Atualmente pesquisa as tendências de longo prazo da desigualdade de renda no Brasil, usando levantamentos históricos e dados administrativos, bem como microdados contemporâneos. Desenvolve também pacotes R (código aberto) para pesquisa social e ferramentas para facilitar o acesso aos dados brasileiros para um público mais amplo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "2_instalacao.html",
    "href": "2_instalacao.html",
    "title": "2  Instalação",
    "section": "",
    "text": "2.1 Instalando R e RStudio\nNesta oficina, a gente pressupõe que você já tenha o R e o RStudio instalados em sua máquina. Caso ainda precise instalar esses programas, siga estras instruções.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalação</span>"
    ]
  },
  {
    "objectID": "2_instalacao.html#instalando-pacotes-de-r",
    "href": "2_instalacao.html#instalando-pacotes-de-r",
    "title": "2  Instalação",
    "section": "2.2 Instalando pacotes de R",
    "text": "2.2 Instalando pacotes de R\nA oficina utiliza alguns pacotes do R que precisam ser instalados em sua máquina. A maneira mais simples de fazer isso é executando o código abaixo. Isso pode levar alguns minutos, caso seja a primeira vez que você instala esses pacotes.\n\npkgs &lt;- c(\n  'censobr',\n  'geobr',\n  'arrow',\n  'dplyr',\n  'ggplot2',\n  'sf'\n  )\n\ninstall.packages(pkgs)\n\nA maneira mais segura de replicar o código desta oficina, no entanto, é clonando o seu repositório localmente. Isso porque este repositório utiliza o pacote {renv}do R para gerenciar as dependências dos pacotes utilizados na oficina. Isso é importante para garantir que estamos utilizando as mesmas versões dos pacotes relevantes.\nUma vez que você clonou o repositório e abriu o arquivo censobr_oficina_abep_2024.Rproj, basta você rodar renv::restore() para instalar todos os pacotes utilizados nesta oficina.\n\n# Descomente a linha abaixo caso precise instalar o pacote {renv}\n# install.packages('renv')\nrenv::restore()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalação</span>"
    ]
  },
  {
    "objectID": "3_info_censo.html",
    "href": "3_info_censo.html",
    "title": "3  Conceitos iniciais",
    "section": "",
    "text": "3.1 Pesquisa da amostra e do universo\nDesde 1960, o Censo Demográfico passou a consistir de duas pesquisas realizadas simultaneamente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conceitos iniciais</span>"
    ]
  },
  {
    "objectID": "3_info_censo.html#pesquisa-da-amostra-e-do-universo",
    "href": "3_info_censo.html#pesquisa-da-amostra-e-do-universo",
    "title": "3  Conceitos iniciais",
    "section": "",
    "text": "Universo: uma pesquisa aplicada a todos os domicílios (ou universo). Esta pesquisa é feita com um questionário básico que costuma ser curto, contendo entre 9 e 30 questões, dependendo da edição do censo.\nAmostra: uma pesquisa amostral aplicada a apenas uma parcela dos domicílios. A fração amostral era de 25% nos anos de 1960, 1970 e 1980 e passou para cerca de 10% em 1991 em diante. Esta pesquisa é feita com um questionário mais extenso.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conceitos iniciais</span>"
    ]
  },
  {
    "objectID": "3_info_censo.html#microdados-da-amostra-e-dados-agregados-do-universo",
    "href": "3_info_censo.html#microdados-da-amostra-e-dados-agregados-do-universo",
    "title": "3  Conceitos iniciais",
    "section": "3.2 Microdados da Amostra e Dados Agregados do Universo",
    "text": "3.2 Microdados da Amostra e Dados Agregados do Universo\nMicrodados são bancos de dados em que cada observação representa uma unidade de coleta de informação. Nos censos, os microdados se referem aos arquivos em que cada observação ou linha são domicílios ou pessoas. A noção de microdados se contrapõe à de dados agregados, nos quais os casos são “agregações” das informações obtidas a partir por exemplo da soma ou das médias das informações dos microdados. Tais agregações podem ser, por exemplo, no nível de bairros, distritos, municípios etc.\n\n\n\n\n\n\nImportante\n\n\n\nOs dados disponibilizados pelo IBGE, e que estão disponíveis no pacote {censobr} são os microdados da pesquisa amostral e os dados do universo agregados por setor censitário.\nObs. O IBGE não disponibiliza os microdados do universo porque a sua divulgação poderia violar o sigilo dos respondentes.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conceitos iniciais</span>"
    ]
  },
  {
    "objectID": "3_info_censo.html#setores-censitários-e-áreas-de-ponderação",
    "href": "3_info_censo.html#setores-censitários-e-áreas-de-ponderação",
    "title": "3  Conceitos iniciais",
    "section": "3.3 Setores Censitários e Áreas de Ponderação",
    "text": "3.3 Setores Censitários e Áreas de Ponderação\nCom os Microdados da Amostra é possível fazer análises por indivíduos, famílias e domicílios. Mas análises espaciais, que levam em conta vizinhanças e distâncias geográficas, por exemplo, também podem ser de interesse. Nesse caso, é importante ter ciência da granularidade dos dados – i.e. de qual a menor unidade espacial que permite inferência estatística. Para isso, cabe destacar as duas principais unidades espaciais na construção dos censos demográficos:\n\n3.3.1 Setores censitários\n\nOs setores censitários são a menor unidade de análise espacial nas pesquisas domiciliares do IBGE. Um setor é uma unidade territorial demarcada para fins operacionais de organizar a coleta de dados. Cada setor é coberto por um único recenseador e possui em média, cerca de 200 domicílios. No entanto, este número, assim como a o tamanho do setor podem variar a depender da densidade demográfica de cada região. Os dados do universo são disponibilizados apenas no formato agregado por setores censitários.\n\n\n\n3.3.2 Áreas de ponderação\n\nAs áreas de ponderação são a menor unidade espacial para a qual os dados da pesquisa amostral possuem representatividade estatística. Essas áreas são constituídas por agrupamentos de setores censitários contíguos, mas que também variam de acordo com a densidade demográfica de cada região. Para o Censo de 2010, o IBGE estabeleceu que uma área de ponderação deveria ter, no mínimo, 400 domicílios ocupados na amostra. Em regiões menos densamente povoadas, essas áreas acabam ocupando uma larga extensão territorial.\n\n\n\nCódigo\nlibrary(geobr)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(sf)\n\n# codigo do municipio de Belford Roxo\nmymuni &lt;- 3300456\n\n# baixa geometria do municipio\nmuni &lt;- geobr::read_municipality(mymuni)\n\n# baixa geometria das areas de ponderacao\nap &lt;- geobr::read_weighting_area(code_weighting = mymuni, \n                                 year = 2010, \n                                 simplified = F)\n\n# baixa geometria dos setores censitarios\nct &lt;- geobr::read_census_tract(code_tract = mymuni, \n                               year = 2010, \n                               simplified = FALSE)\n\n# funcao para 'inclinar' mapa\nrotate_data_geom &lt;- function(data, x_add = 0, y_add = 0) {\n  shear_matrix &lt;- function(){ matrix(c(2, 1.2, 0, 1), 2, 2) }\n  \n  rotate_matrix &lt;- function(x) { \n    matrix(c(cos(x), sin(x), -sin(x), cos(x)), 2, 2) \n  }\n  dplyr::mutate(data,\n    geom = geom * shear_matrix() * rotate_matrix(pi/20) + c(x_add, y_add)\n    )\n}\n\n\n# annotate parameters\nx = -116.03\nclr = 'gray40'\nsz = 4\n\n# MAP\ntemp1  &lt;- ggplot() +\n  # municipio\n  geom_sf(data = rotate_data_geom(data = muni, y_add = .01),\n          color='gray30', fill='#FCDE70', show.legend = FALSE) +\n  annotate(\"text\", label='Município', x=x, y=-4.59,\n           hjust = 0, color=clr, size=sz) +\n  \n  # areas de ponderacao\n  geom_sf(data = rotate_data_geom(data = ap, y_add = .07), \n          fill='#ff7b7b', color='#ff0000', show.legend = FALSE) +\n  annotate(\"text\", label='Áreas de\\nPonderação', x=x, y= -4.53,\n           hjust = 0, color=clr, size=sz) +\n\n  # setores censitarios\n  geom_sf(data = rotate_data_geom(data = ct, y_add = 0.13),\n          color='gray30', fill='gray98', show.legend = FALSE) +\n  annotate(\"text\", label='Setores\\nCensitários', x=x, y= -4.47, \n           hjust = 0, color=clr, size=sz) +\n  coord_sf(xlim = c(-116.305, -115.98)) +\n  theme_void() +\n  theme(plot.background = element_rect(fill = 'white', color='white'))\n\ntemp1\n# ggsave(temp1, filename = 'fig_spatial_layers.png', \n#        width = 12, height = 8, units = 'cm', dpi = 300)\n\n\n\n\n\n\n\n\n\n\n\nIBGE. 1990. Estatisticas historicas do Brasil : series economicas demograficas e sociais de 1550 a 1988. IBGE. https://biblioteca.ibge.gov.br/index.php/biblioteca-catalogo?view=detalhes&id=221431.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conceitos iniciais</span>"
    ]
  },
  {
    "objectID": "4_microdados.html",
    "href": "4_microdados.html",
    "title": "4  Microdados",
    "section": "",
    "text": "4.1 Dados disponíveis no {censobr}\nO {censobr} é um pacote de R para acessar os dados e documentação dos censos demográficos do Brasil (Pereira e Barbosa 2023). O pacote disponibiliza microdados da amostra de todas as edições do censo demográfico desde 1970. A Tabela 1 apresenta abaixo todas as bases de dados do censo que você consegue acessar com o {censobr}.\nTabela 1. Funções de dados disponíveis no {censobr}\nTodas as funções de leitura de microdados possuem a mesma estrutra (sintaxe), o que permite o usuário baixar os dados de maneira fácil e intuitiva com um único comando. As funções possuem os seguintes parâmetros:\nread_households(\n  year,          # ano de referência\n  columns,       # seleciona colunas que devem ser lidas\n  add_labels,    # adiciona os 'labels' das variáveis categóricas\n  as_data_frame, # retorna resultado como um `Arrow DataSet` ou `data.frame`\n  showProgress,  # mostra contagem de download\n  cache          # salva arquivo em cache para rapida leitura posteriormente\n  )",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#dados-disponíveis-no-censobr",
    "href": "4_microdados.html#dados-disponíveis-no-censobr",
    "title": "4  Microdados",
    "section": "",
    "text": "Função\nOrigem\nUnidade\nDefinição\nDisponibilidade\n\n\n1960\n70\n80\n91\n2000\n10\n22\n\n\n\n\nread_population()\nAmostra\nMicrodado\nLê os microdados de pessoas\nX\nX\nX\nX\n\nX\nem breve\n\n\nread_households()\nAmostra\nMicrodado\nLê os microdados de domicílios\nX\nX\nX\nX\nX\nX\nem breve\n\n\nread_families()\nAmostra\nMicrodado\nLê os microdados de famílias do censo de 2000\n\n\n\nX\n\n\n\n\n\nread_emigration()\nAmostra\nMicrodado\nLê os microdados de emigração\n\n\n\n\nX\n\nem breve\n\n\nread_mortality()\nAmostra\nMicrodado\nLê os microdados de mortalidade\n\n\n\n\n\nX\nem breve\n\n\nread_tracts()\nUniverso\nSetor Censitário\nLê os dados do Universo agregados por setores censitários\n\n\n\n\nem breve\nX\nem breve\n\n\n\n\n\n\n\n\n\n\n\nCache local dos dados\n\n\n\nA primeira vez que o usuário executa uma função, o {censobr} fará o download dos dados e os armazenará localmente numa pasta do pacote. Dessa forma, os dados precisam ser baixados apenas uma vez. Mais informações na seção Cache de Dados abaixo.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#trabalhando-com-dados-maior-do-que-a-ram",
    "href": "4_microdados.html#trabalhando-com-dados-maior-do-que-a-ram",
    "title": "4  Microdados",
    "section": "4.2 Trabalhando com dados maior do que a RAM",
    "text": "4.2 Trabalhando com dados maior do que a RAM\n\n\n\n\n\nÉ muito comum que os microdados do censo brasileiro sejam grandes demais para serem carregados na memória RAM do usuário. Para resolver esse problema, o {censobr} foi construído sobre a plataforma Arrow e arquivos em formato .parquet, o que permite que o usuário trabalhe de maneira eficiente até mesmo com bases de dados muito grandes utilizando funções já bem conhecidas do pacote {dplyr}.\nVamos então partir para exemplos na prática, e começar carregando as bibliotecas que usamos.\n\n# carrega bibliotecas\nlibrary(censobr)\n\nWarning: package 'censobr' was built under R version 4.3.3\n\nlibrary(arrow)\n\nWarning: package 'arrow' was built under R version 4.3.3\n\nlibrary(dplyr)\nlibrary(ggplot2)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#dados-de-população",
    "href": "4_microdados.html#dados-de-população",
    "title": "4  Microdados",
    "section": "4.3 Dados de população",
    "text": "4.3 Dados de população\nNeste exemplo, nós vamos criar um gráfico da pirâmica populacional do Brasil no ano de 2010. O primeiro passo é usar a função read_population() para carregar os microdados de população.\nO comportamento padrão das as funções do {censobr} é retornar todas as variáveis das bases de dados. No entanto, como vamos fazer uma análise simples, o mais eficiente é passarmos um vetor com os nomes das colunas que vamos utilizar (neste caso, as variáveis de peso amostral, sexo e idade).\n\npop &lt;- read_population(\n  year = 2010,\n1  columns = c('V0010', 'V0601', 'V6036'),\n2  add_labels = 'pt',\n  showProgress = FALSE\n  )\n\nclass(pop)\n\n\n1\n\nAumentando eficiência ao ler apenas as colunas que vamos usar\n\n2\n\nAdicionando os ‘labels’ em Português das variáveis categóricas.\n\n\n\n\n[1] \"arrow_dplyr_query\"\n\n\nPor padrão, a saída da função é um \"arrow_dplyr_query\" ou \"ArrowObject\". Isso permite que você trabalhe com os dados do censo de maneira super rápida e eficiente, mesmo que a tabela de dados seja grande demais para a memória do seu computador. Note que se você passar o parâmetro as_data_frame = TRUE, a função carregará os dados como um data.frame na memória RAM. Atenção: isso pode fazer com que a sessão do R trave em ambientes com restrições computacionais.\nEsse output em arrow pode ser analisado como de maneira similar a como se analisaria um data.frame utilizando-se funções do pacote {dplyr}. Uma diferença, no entanto, é que as operações somente são executadas quando o usuário roda a função dplyr::collect()\nAqui, por exemplo, nós visualizamos as primeiras linhas da tabela de dados:\n\nhead(pop) |&gt; collect()\n\nWarning: Potentially unsafe or invalid elements have been discarded from R metadata.\nℹ Type: \"externalptr\"\n→ If you trust the source, you can set `options(arrow.unsafe_metadata = TRUE)` to preserve them.\nPotentially unsafe or invalid elements have been discarded from R metadata.\nℹ Type: \"externalptr\"\n→ If you trust the source, you can set `options(arrow.unsafe_metadata = TRUE)` to preserve them.\n\n\n     V0010     V0601 V6036\n1 8.705865 Masculino    22\n2 8.705865  Feminino    17\n3 9.818689 Masculino    38\n4 9.495608  Feminino    44\n5 9.495608 Masculino    11\n6 9.495608 Masculino    16\n\n\nO próximo passo é criar um variável categória com grupos de idade a cada 5 anos.\n\npop &lt;- pop |&gt;\n  mutate(\n    age_group = dplyr::case_when(\n      V6036 &lt;= 04              ~ \"00-05\",\n      V6036 &gt;= 05 & V6036 &lt; 10 ~ \"05-10\",\n      V6036 &gt;= 10 & V6036 &lt; 15 ~ \"10-15\",\n      V6036 &gt;= 15 & V6036 &lt; 20 ~ \"15-20\",\n      V6036 &gt;= 20 & V6036 &lt; 25 ~ \"20-25\",\n      V6036 &gt;= 25 & V6036 &lt; 30 ~ \"25-30\",\n      V6036 &gt;= 30 & V6036 &lt; 35 ~ \"30-35\",\n      V6036 &gt;= 35 & V6036 &lt; 40 ~ \"35-40\",\n      V6036 &gt;= 40 & V6036 &lt; 45 ~ \"40-45\",\n      V6036 &gt;= 45 & V6036 &lt; 50 ~ \"45-50\",\n      V6036 &gt;= 50 & V6036 &lt; 55 ~ \"50-55\",\n      V6036 &gt;= 55 & V6036 &lt; 60 ~ \"55-60\",\n      V6036 &gt;= 60 & V6036 &lt; 65 ~ \"60-65\",\n      V6036 &gt;= 65 & V6036 &lt; 70 ~ \"65-70\",\n      V6036 &gt;= 70              ~ \"75+\"\n      ))\n\nhead(pop) |&gt; collect()\n\nWarning: Potentially unsafe or invalid elements have been discarded from R metadata.\nℹ Type: \"externalptr\"\n→ If you trust the source, you can set `options(arrow.unsafe_metadata = TRUE)` to preserve them.\nPotentially unsafe or invalid elements have been discarded from R metadata.\nℹ Type: \"externalptr\"\n→ If you trust the source, you can set `options(arrow.unsafe_metadata = TRUE)` to preserve them.\n\n\n     V0010     V0601 V6036 age_group\n1 8.705865 Masculino    22     20-25\n2 8.705865  Feminino    17     15-20\n3 9.818689 Masculino    38     35-40\n4 9.495608  Feminino    44     40-45\n5 9.495608 Masculino    11     10-15\n6 9.495608 Masculino    16     15-20\n\n\nE em seguida, nós só precisamos somar o número de homens e mulheres em cada grupo de idade. Para isso, nós somamos os valores da variável de peso amostral V0010 em cada grupo. Repare que ao chamarmos a função collect(), o código é executado e retorna um data.frame.\n\npiramide_df &lt;- pop |&gt;\n               group_by(V0601, age_group) |&gt;\n               summarise(pop_count = sum(V0010)) |&gt;\n               collect()\n\nWarning: Potentially unsafe or invalid elements have been discarded from R metadata.\nℹ Type: \"externalptr\"\n→ If you trust the source, you can set `options(arrow.unsafe_metadata = TRUE)` to preserve them.\n\nhead(piramide_df)\n\n# A tibble: 6 × 3\n# Groups:   V0601 [2]\n  V0601     age_group pop_count\n  &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;\n1 Masculino 20-25      8627665.\n2 Feminino  15-20      8429180.\n3 Masculino 35-40      6767177.\n4 Feminino  40-45      6688525.\n5 Masculino 10-15      8727095.\n6 Masculino 15-20      8557608.\n\n\nPronto, no último passo é só fazer o gráfico de pirâmide populacional utilizando o pacote {ggplot2}.\n\n\nCódigo\n# remove grupo com idade missing `NA`\npiramide_df &lt;- filter(piramide_df, !is.na(age_group))\n\n# transforma a contagem de mulheres para valores negativos\npiramide_df &lt;- piramide_df |&gt;\n  mutate(pop_count = if_else(V0601 == \"Masculino\", pop_count, -pop_count))\n\n# figura\nggplot(data = piramide_df,\n       aes(x = pop_count / 1000,\n           y = age_group,\n           fill = V0601)) +\n  geom_col() +\n  scale_fill_discrete(name=\"\", type=c(\"#ffcb69\",\"#437297\")) +\n  scale_x_continuous(labels = function(x){scales::comma(abs(x))},\n                     breaks = c(-8000, -4000,0,4000, 8000),\n                     name = \"População (em milhares)\") +\n  theme_classic() +\n  theme(\n    legend.position = \"top\",\n    axis.title.y=element_blank(),\n    panel.grid.major.x = element_line(color = \"grey90\")\n  )\n\n\n\n\n\nPirâmide demográfica, Brasil, 2010",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#dados-de-domicílios",
    "href": "4_microdados.html#dados-de-domicílios",
    "title": "4  Microdados",
    "section": "4.4 Dados de domicílios",
    "text": "4.4 Dados de domicílios\n\n4.4.1 Saneamento:\nNeste exemplo, nós vamos usar os dados de domicílios do censo de 2010 para calcular qual proporção de domicílios conectados à rede de esgoto nos municípios de cada região do Brasil. O primeiro passo é baixar os dados utilizando a função read_households().\n\ndom &lt;- read_households(year = 2010, \n                      showProgress = FALSE)\n\nAgora vamos (a) agrupar as observações por região e município, (b) obter o número de domicílios conectados à rede de esgoto, (c) obter o número total de domicílios, (d) calcular a proporção de domicílios conectados e (e) coletar os resultados.\n\nesg &lt;- dom |&gt; \n        compute() |&gt;\n        group_by(name_region, code_muni) |&gt;                  # (a)\n        summarize(rede = sum(V0010[which(V0207=='1')]),      # (b)\n                  total = sum(V0010)) |&gt;                     # (c)\n        mutate(cobertura = rede / total) |&gt;                  # (d)\n        collect()                                            # (e)\n\nhead(esg)\n\n# A tibble: 6 × 5\n# Groups:   name_region [1]\n  name_region  code_muni   rede  total cobertura\n  &lt;chr&gt;            &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;\n1 Centro-oeste   5000203   73.4  4534.   0.0162 \n2 Centro-oeste   5000252   10.3  1596.   0.00646\n3 Centro-oeste   5000609 2150.  11012.   0.195  \n4 Centro-oeste   5000708 1705.   7419.   0.230  \n5 Centro-oeste   5000807   35.9  2759.   0.0130 \n6 Centro-oeste   5000856   12.4  3053.   0.00407\n\n\nUma rápida análise da dispersão dos valores com o box-plot abaixo já revela um dos retratos da desigualdade regional brasileira. Menos de 50% dos domicílios estão conectados à rede de esgoto em todos municípios da região Norte e quase metade dos municípios da região Nordeste. No próximo bloco, nós vamos visualizar essas diferenças se distribuem espacialmente.\n\nggplot(esg) +\n  geom_boxplot(aes(x=reorder(name_region, -cobertura), y=cobertura, \n                   weight  = rede, color=name_region), \n               show.legend = F, outlier.alpha = 0.1) +\n  scale_y_continuous(labels = scales::percent) +\n  labs(x=\"Região\", y=\"Quantidade de domicílios\\nconectados à rede de esgoto\") +\n  theme_classic()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#análise-espacial-com-geobr",
    "href": "4_microdados.html#análise-espacial-com-geobr",
    "title": "4  Microdados",
    "section": "4.5 Análise espacial com {geobr}",
    "text": "4.5 Análise espacial com {geobr}\nO {geobr} é um pacote para baixar dados espaciais oficiais do Brasil (Pereira e Gonçalves 2019). Ele inclui uma ampla variedade de dados geoespaciais disponíveis em várias escalas geográficas e para diversos anos, como municípios, regiões metropolitanas, biomas, estabelecimentos de saúde, etc (veja a lista completa no site do pacote).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#integração-entre-censobr-e-geobr",
    "href": "4_microdados.html#integração-entre-censobr-e-geobr",
    "title": "4  Microdados",
    "section": "4.6 Integração entre {censobr} e {geobr}",
    "text": "4.6 Integração entre {censobr} e {geobr}\n\n \n\n\nTodos os dados do {censobr} são enriquecidos com colunas de geografia, seguindo os padrões de nomenclatura do pacote {geobr} para facilitar a manipulação e a integração de dados espaciais dos censos demográficos do Brasil. As colunas adicionadas são: c('code_muni', 'code_state', 'abbrev_state', 'name_state', 'code_region', 'name_region', 'code_weighting', 'code_tract').\n\nPara criarmos uma mapa com a distribuição espacial da cobertura de esgotamento no Brasil, nós vamos primeiro usar o pacote {geobr} para baixar as geometrias dos municípios brasileiros no anos de 2010. Vamos também sobrepor os limites das grandes regiões do país para dar um pouco mais de contexto à figura.\n\nlibrary(geobr)\n\nregioes_df &lt;- read_region(year = 2010,\n                          showProgress = FALSE)\n\nmuni_sf &lt;- read_municipality(year = 2010,\n                             showProgress = FALSE)\n\nhead(muni_sf)\n\nSimple feature collection with 6 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -63.61822 ymin: -13.6937 xmax: -60.33317 ymax: -9.66916\nGeodetic CRS:  SIRGAS 2000\n  code_muni             name_muni code_state abbrev_state\n1   1100015 Alta Floresta D'oeste         11           RO\n2   1100023             Ariquemes         11           RO\n3   1100031                Cabixi         11           RO\n4   1100049                Cacoal         11           RO\n5   1100056            Cerejeiras         11           RO\n6   1100064     Colorado Do Oeste         11           RO\n                            geom\n1 MULTIPOLYGON (((-62.2462 -1...\n2 MULTIPOLYGON (((-63.13712 -...\n3 MULTIPOLYGON (((-60.52408 -...\n4 MULTIPOLYGON (((-61.42679 -...\n5 MULTIPOLYGON (((-61.41347 -...\n6 MULTIPOLYGON (((-60.66352 -...\n\n\nAgora nós só precisamos unir os dados espaciais com nossas estimativas utilizando a variável chave code_muni e mapear os resultados.\n\n# merge data\nesg_sf &lt;- left_join(muni_sf, esg, by = 'code_muni')\n\n# plot map\nggplot() +\n  geom_sf(data = esg_sf, aes(fill = cobertura), color=NA) +\n  geom_sf(data = regioes_df, color = 'gray20', fill=NA) +\n  labs(title = \"Quantidade de domicílios conectados à rede de esgoto\") +\n  scale_fill_distiller(palette = \"Greens\", direction = 1, \n                       name='Proporção de\\ndomicílios', \n                       labels = scales::percent) +\n  theme_void() +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\n\n4.6.1 Distribuição espacial do valor do aluguel:\nNo exemplo anterior, nós agregamos os microdados do censo no nível de municípios. Neste próximo exemplo, faremos uma análise espacial no nível de áreas de ponderação. Aqui nós vamos visualizar como o valor do aluguel varia espacialmente na região metropolitana de São Paulo.\nPrimeiro, vamos baixar os municípios da região metropolitana de São Paulo com o {geobr}.\n\nmetro_muni &lt;- geobr::read_metro_area(year = 2010,\n                                     showProgress = FALSE) |&gt; \n              filter(name_metro == \"RM São Paulo\")\n\nTambém precisamos dos polígonos das áreas de ponderação. Com o código abaixo, baixamos todas as áreas de ponderação do estado de São Paulo e, em seguida, mantemos apenas aquelas na região metropolitana de São Paulo.\n\nwt_areas &lt;- geobr::read_weighting_area(code_weighting = \"SP\",\n                                       year = 2010,\n                                       simplified = FALSE,\n1                                       showProgress = FALSE)\n\n\n1\n\nO comportamento padrão do {geobr} é baixar uma versão da malha espacial com geometrias ligeiramente simplificadas (simplified = TRUE) para agilizar o processamento e visualização de dados. Aqui, nós baixamos os dados com geometrias originais devido à escala espacial da visualização dos resultados.\n\n\n\n\nUsing year/date 2010\n\nwt_areas &lt;- filter(wt_areas, code_muni %in% metro_muni$code_muni)\nhead(wt_areas)\n\nSimple feature collection with 6 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -46.73454 ymin: -23.64487 xmax: -46.64756 ymax: -23.53528\nGeodetic CRS:  SIRGAS 2000\n  code_weighting code_muni name_muni code_state abbrev_state code_region\n1  3550308005100   3550308 São Paulo         35           SP           3\n2  3550308005102   3550308 São Paulo         35           SP           3\n3  3550308005101   3550308 São Paulo         35           SP           3\n4  3550308005104   3550308 São Paulo         35           SP           3\n5  3550308005103   3550308 São Paulo         35           SP           3\n6  3550308005106   3550308 São Paulo         35           SP           3\n  name_region                           geom\n1     Sudeste MULTIPOLYGON (((-46.67201 -...\n2     Sudeste MULTIPOLYGON (((-46.67663 -...\n3     Sudeste MULTIPOLYGON (((-46.67257 -...\n4     Sudeste MULTIPOLYGON (((-46.70138 -...\n5     Sudeste MULTIPOLYGON (((-46.69581 -...\n6     Sudeste MULTIPOLYGON (((-46.73454 -...\n\n\nAgora voltamos para a base de dados de domicílios do censo de 2010. Com essa base, nós precisamos calcular o valor médio do aluguel gasto em cada área de ponderação. Note que para isso nós usamos a média do aluguel V2011 ponderada pela variável do peso do domicílio V0010. Para encontrar esses valores, o código abaixo (a) filtra apenas as observações nos nossos municípios de interesse, (b) computa temporariamente o resultado, (c) agrupa as observações por área de ponderação, (d) calcula o valor médio do aluguel e (e) coleta os resultados.\n\nrent &lt;- dom |&gt;\n        filter(code_muni %in% metro_muni$code_muni) |&gt;                     # (a)\n        compute() |&gt;                                                       # (b)\n        group_by(code_weighting) |&gt;                                        # (c)\n        summarize(avgrent=weighted.mean(x=V2011, w=V0010, na.rm=TRUE)) |&gt;  # (d)\n        collect()                                                          # (e)\n\nhead(rent)\n\n# A tibble: 6 × 2\n  code_weighting avgrent\n  &lt;chr&gt;            &lt;dbl&gt;\n1 3503901003001     355.\n2 3503901003002     627.\n3 3503901003003     358.\n4 3505708005001     577.\n5 3505708005002     397.\n6 3505708005003     327.\n\n\nPor fim, podemos unir os dados espaciais com nossas estimativas de aluguel pela variável chave code_weighting, e mapear os resultados.\n\nrent_sf &lt;- left_join(wt_areas, rent, by = 'code_weighting')\n\nggplot() +\n  geom_sf(data = rent_sf, aes(fill = avgrent), color=NA) +\n  geom_sf(data = metro_muni, color='gray', fill=NA) +\n  labs(title = \"Valor médio do aluguel por área de ponderação\",\n       subtitle = \"Região Metropolitana de São Paulo, 2010\") +\n  scale_fill_distiller(palette = \"Purples\", direction = 1, \n                       name='Valores\\nem R$',\n                       labels = scales::number_format(big.mark = \".\")) +\n  theme_void()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "4_microdados.html#data-cache",
    "href": "4_microdados.html#data-cache",
    "title": "4  Microdados",
    "section": "4.7 Data cache",
    "text": "4.7 Data cache\nNa primeira vez que o usuário executa uma função, o {censobr} fará o download do arquivo e o armazenará localmente. Dessa forma, os dados só precisam ser baixados uma vez. Quando o parâmetro cache está configurado como TRUE (Padrão), a função lerá os dados em cache, o que é muito mais rápido.\nOs usuários podem gerenciar os conjuntos de dados em cache usando a função censobr_cache(). Por exemplo, os usuários podem:\nListar arquivos em cache:\n\ncensobr_cache(list_files = TRUE)\n\nDeletar um arquivo específico:\n\ncensobr_cache(delete_file = \"2010_emigration\")\n\nDeletar todos arquivos do cache:\n\ncensobr_cache(delete_file = \"all\")\n\nPor padrão, os arquivos do {censobr} são salvos no diretório ‘User’. No entanto, os usuários podem executar a função set_censobr_cache_dir() para definir um diretório de cache personalizado. Note que essa definição personalizada precisa ser definida a cada nova sessão do R.\n\ntempf &lt;- tempdir()\n\nset_censobr_cache_dir(path = tempf)\n\n\n\n\n\nPereira, Rafael H. M., e Rogério J. Barbosa. 2023. censobr: Download Data from Brazil’s Population Census. CRAN. https://doi.org/10.32614/CRAN.package.censobr.\n\n\nPereira, Rafael H. M., e Caio N. Gonçalves. 2019. geobr: Download Official Spatial Data Sets of Brazil. CRAN. https://doi.org/10.32614/CRAN.package.geobr.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Microdados</span>"
    ]
  },
  {
    "objectID": "5_agregados_setores.html",
    "href": "5_agregados_setores.html",
    "title": "5  Agregados dos Setores Censitários",
    "section": "",
    "text": "5.1 Estrutura dos dados\nNo seu formato original, os dados agregados no nível do setores censitários estão divididos em diferentes tipos de variáveis (e.g. variáveis de características de pessoas, de domicílios, etc). Em muitos casos, esses conjuntos de variáveis estão espalhadas por vários arquivos (em alguns casos com centenas variáveis). Para facilitar o entendimento desses dados, o {censobr} reúne todos os arquivos / variáveis em 8 tabelas:\nTodos estas tabelas estão organizados seguindo a mesma lógica. Nos casos em que as variáveis de uma tabela provêm de arquivos diferentes, o nome da variável recebe um prefixo indicando a sua tabela de origem. Isso é feito para facilitar a consulta do significado de cada coluna no arquivo de dicionário variáveis.\nPara ilustrar isso, vejamos a tabela com variáveis de \"Domicilio\". Essa tabela provêm de dois arquivos separados: Domicilio01 e Domicilio02. Assim, os nomes das colunas nessa tabela são organizados da seguinte maneira:\nlibrary(censobr)\n\n# baixa dados agregados de setores: variáveis de domicilios\ndom &lt;- read_tracts(year = 2010, \n                   dataset = 'Domicilio',\n                   as_data_frame = FALSE,\n                   showProgress = FALSE)\n\nnames(dom)[c(1:20,301:320)]\n\n [1] \"code_tract\"        \"code_weighting\"    \"code_muni\"        \n [4] \"code_state\"        \"abbrev_state\"      \"name_state\"       \n [7] \"code_region\"       \"name_region\"       \"domicilio01_V1005\"\n[10] \"domicilio01_V001\"  \"domicilio01_V002\"  \"domicilio01_V003\" \n[13] \"domicilio01_V004\"  \"domicilio01_V005\"  \"domicilio01_V006\" \n[16] \"domicilio01_V007\"  \"domicilio01_V008\"  \"domicilio01_V009\" \n[19] \"domicilio01_V010\"  \"domicilio01_V011\"  \"domicilio02_V050\" \n[22] \"domicilio02_V051\"  \"domicilio02_V052\"  \"domicilio02_V053\" \n[25] \"domicilio02_V054\"  \"domicilio02_V055\"  \"domicilio02_V056\" \n[28] \"domicilio02_V057\"  \"domicilio02_V058\"  \"domicilio02_V059\" \n[31] \"domicilio02_V060\"  \"domicilio02_V061\"  \"domicilio02_V062\" \n[34] \"domicilio02_V063\"  \"domicilio02_V064\"  \"domicilio02_V065\" \n[37] \"domicilio02_V066\"  \"domicilio02_V067\"  \"domicilio02_V068\" \n[40] \"domicilio02_V069\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Agregados dos Setores Censitários</span>"
    ]
  },
  {
    "objectID": "5_agregados_setores.html#estrutura-dos-dados",
    "href": "5_agregados_setores.html#estrutura-dos-dados",
    "title": "5  Agregados dos Setores Censitários",
    "section": "",
    "text": "\"Basico\"\n\"Entorno\"\n\"Domicilio\"\n\"Pessoa\"\n\"Responsavel\"\n\"PessoaRenda\"\n\"DomicilioRenda\"\n\"ResponsavelRenda\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Agregados dos Setores Censitários</span>"
    ]
  },
  {
    "objectID": "5_agregados_setores.html#dicionário-de-variáveis",
    "href": "5_agregados_setores.html#dicionário-de-variáveis",
    "title": "5  Agregados dos Setores Censitários",
    "section": "5.2 Dicionário de variáveis",
    "text": "5.2 Dicionário de variáveis\nPara verificar o significado de cada variável, você pode executar o comando data_dictionary(), que abrirá no navegador um arquivo .html ou .pdf com o dicionário de variáveis de cada conjunto de dados (ver mais info no capítulo 6 sobre Documentação).\n\ndata_dictionary(year = 2010,\n                dataset = 'tracts')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Agregados dos Setores Censitários</span>"
    ]
  },
  {
    "objectID": "5_agregados_setores.html#exemplos-reproduzíveis",
    "href": "5_agregados_setores.html#exemplos-reproduzíveis",
    "title": "5  Agregados dos Setores Censitários",
    "section": "5.3 Exemplos reproduzíveis",
    "text": "5.3 Exemplos reproduzíveis\nEssa organização dos dados agregados por setores censitários parece confusa a primeira vista. E é mesmo. Mas essa organização fica mais clara com alguns exemplos práticos.\nNesta seção, nós vamos utilizar alguns exemplos para ilustrar como trabalhar com dados no nível de setor censitário. Primeiro, precisamos carregar as bibliotecas que usaremos neste tutorial.\n\nlibrary(censobr)\nlibrary(geobr)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nNos dois exemplos abaixo, usaremos a cidade de Belo Horizonte para fins de demonstração. No primeiro exemplo, nós vamos mapear a distribuição espacial da renda com dados de 2010. No segundo exemplo, nós vamos mapear a distribuição espacial da densidade populacional de BH com os dados preliminares do censo de 2022.\n\n5.3.1 Exemplo 1: Distribuição espacial da renda em 2010\nNeste primeiro exemplo, criaremos um mapa da distribuição espacial da renda média per capita. A informação sobre o número total de residentes em cada setor censitário está disponível na tabela com conjunto de variáveis do bloco \"Basico\", na variável \"V002\". Já a informação sobre renda total do setor censiário pode ser encontradas na tabela do bloco \"DomicilioRenda\", na variável \"V003\".\nUtilizando o código abaixo, podemos baixar os dados e calcular a renda per capita de todos os setores censitários no Brasil. Posteriormente nós vamos filtrar esses resultados para ficar apenas com os setores de BH.\n\n# baixa os dados\n1tract_basico &lt;- read_tracts(year = 2010,\n                            dataset = \"Basico\",\n                            showProgress = FALSE)\n\ntract_income &lt;- read_tracts(year = 2010,                 \n                            dataset = \"DomicilioRenda\",\n2                            showProgress = FALSE)\n\n# selecionar conlunas\n3tract_basico &lt;- tract_basico |&gt; select('code_tract','V002')\ntract_income &lt;- tract_income |&gt; select('code_tract','V003')\n\n# unir as tabelass\n4tracts_df10 &lt;- left_join(tract_basico, tract_income) |&gt;\n                collect()\n\n# calcular a renda per capita\n5tracts_df10 &lt;- tracts_df10 |&gt; mutate(income_pc = V003 / V002)\n\nhead(tracts_df10)\n\n\n1\n\nDownload de dados do bloco Basico\n\n2\n\nDownload de dados do bloco DomicilioRenda\n\n3\n\nSeleciona apenas as variáveis que vamos utilizar\n\n4\n\nJunta as duas variáveis num único data.frame\n\n5\n\nCacula renda per capita de cada setor censitário\n\n\n\n\n        code_tract  V002   V003 income_pc\n            &lt;char&gt; &lt;num&gt;  &lt;num&gt;     &lt;num&gt;\n1: 120001305000001   957 601805  628.8454\n2: 120001305000002  1203 385033  320.0607\n3: 120001305000003  1700 531794  312.8200\n4: 120001305000004   182  58853  323.3681\n5: 120001305000005   305 112979  370.4230\n6: 120001305000006   483 263538  545.6273\n\n\nO próximo passo é baixar as geometrias dos setores censitários de BH em 2010 com a função read_census_tract, do pacote {geobr}. Aqui, nós passamos o parâmetro code_tract = \"MG\" baixar os todos os setores do estado de Minas Gerais e depois filtramos apenas o município de Belo Horizonte.\n\n# busca qual o código do municipio de Belo Horizonte\nbh_info &lt;- geobr::lookup_muni(name_muni = 'Belo Horizonte')\n#&gt; code_muni: 3106200\n\n# baixa municipio de BH\nmuni_bh &lt;- geobr::read_municipality(code_muni = 'MG', \n                                    year = 2010,\n                                    showProgress = FALSE) |&gt;\n           filter(name_muni == \"Belo Horizonte\")\n\n# baixa todos setores de Minas Gerais\ntracts_2010 &lt;- geobr::read_census_tract(code_tract = \"MG\",\n                                        year = 2010,\n                                        simplified = FALSE,\n1                                        showProgress = FALSE)\n\n# filtra setores de BH\ntracts_2010 &lt;- filter(tracts_2010, name_muni == 'Belo Horizonte')\n\n# mapa de setores censitarios\nggplot() + \n  geom_sf(data=tracts_2010, fill = 'gray90', color='gray60') +\n  theme_void()\n\n\n1\n\nO comportamento padrão do {geobr} é baixar uma versão da malha espacial com geometrias ligeiramente simplificadas (simplified = TRUE) para agilizar o processamento e visualização de dados. Aqui, nós baixamos os dados com geometrias originais devido à escala espacial da visualização dos resultados.\n\n\n\n\n\n\n\n\n\n\n\nPor fim, a gente pode fazer um merge dos dados espaciais e de renda dos setores censitários usando a variável chave code_tract e criar o mapa da distribuição espacial de renda.\n\nbh_tracts &lt;- left_join(tracts_2010, tracts_df10, by = 'code_tract')\n\nggplot() +\n  geom_sf(data = bh_tracts, aes(fill = ifelse(income_pc&lt;10000,income_pc,10000)), \n          color=NA) +\n  geom_sf(data = muni_bh, color='gray10', fill=NA) +\n  labs(title = 'Renda per capita dos setores censitários',\n       subtitle= 'Belo Horizonte, 2010') +\n  scale_fill_viridis_c(name = \"Reda per\\ncapita (R$)\",\n                       na.value=\"white\",\n                       option = 'cividis',\n                       breaks = c(0,  1e3, 4e3, 8e3, 1e4) ,\n                        labels  = c('0',  '1.000', '4.000', '8.000', '&gt; 10.000')\n                       ) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n5.3.2 Examplo 2: Distribuição espacial da população em 2022\nNeste segundo exemplo, nós vamos utilizar os resultados \"Preliminares\" dos agregados dos setores censitários do censo de 2022, que foram divulgados pelo IBGE em março de 2024. Em particular, vamos utilizar a variável V0001 que informa a população total dos setores. Além disso, como houve uma mudança na malha de setores censitários entre 2010 e 2022, nós precisamos baixar a malha do ano correspondente.\n\n# download dados preliminares dos setores de 2022\ntracts_df22 &lt;- read_tracts(year = 2022,\n                          dataset = \"Preliminares\",\n                          showProgress = FALSE) |&gt;\n               filter(name_muni == 'Belo Horizonte') |&gt;\n               collect()\n\n# baixa todos setores de Minas Gerais\ntracts_2022 &lt;- geobr::read_census_tract(code_tract = \"MG\",\n                                        year = 2022,\n                                        simplified = FALSE,\n                                        showProgress = FALSE)\n\n# filtra setores de BH\ntracts_2022 &lt;- filter(tracts_2022, name_muni == 'Belo Horizonte')\n\nAgora a gente pode fazer um merge da tabela de população com os dados espaciais, calcular a área em Km2 e a densidade demográfica de cada setor, e criar o mapa.\n\n# merge tables\ntracts_df22$code_tract &lt;- as.numeric(tracts_df22$code_tract)\nbh_tracts22 &lt;- left_join(tracts_2022, tracts_df22, by = 'code_tract')\n\n# calcula a área dos setores\nbh_tracts22 &lt;- bh_tracts22 |&gt;\n              mutate(tract_aream2 = sf::st_area(tracts_2022),\n                     tract_areakm2 = units::set_units(tract_aream2, km2))\n\n# calcula densidade demografica\nbh_tracts22 &lt;- bh_tracts22 |&gt;\n               mutate(pop_km2 = as.numeric(V0001/ tract_areakm2))\n\n# map\nggplot() +\n  geom_sf(data = bh_tracts22, color=NA,\n          aes(fill = ifelse(pop_km2&lt;20000,pop_km2,20000))) +\n  geom_sf(data = muni_bh, color='gray10', fill=NA) +\n  labs(title = 'Densidade populacional dos setores censitários',\n       subtitle= 'Belo Horizonte, 2022') +\n  scale_fill_distiller(palette = \"Reds\", direction = 1, \n                       name='População por'~Km^2,\n                       breaks = c(0,  5e3, 10e3, 15e3, 2e4) ,\n                       labels  = c('0',  '5.000', '10.000', '15.000', '&gt; 20.000')) +\n  theme_void()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Agregados dos Setores Censitários</span>"
    ]
  },
  {
    "objectID": "6_documentacao.html",
    "href": "6_documentacao.html",
    "title": "6  Documentação dos Censos",
    "section": "",
    "text": "6.1 Documentação do censo disponível no {censobr}\nAlém de funções para leitura dos dados, o pacote {censobr} traz ainda um conjunto de funções que permitem rápido acesso à documentação dos censos demográficos, incluindo os dicionários de variáveis, questionários e manual do entrevistador para entrevistas.\nTabela 2. Funções de documentação disponíveis no {censobr}\nTodas funções de documentação baixam os arquivos em formato .html ou .pdf, e abrem o documento no navegador (browser). Assim como as funções de leitura de dados do {censobr}, essas funções de documentação também salval os arquivos num cache local na primeira vez que a função é rodada. Assim, quando o usuário roda a função novamente, o pacote simplesmente carrega o arquivo local de maneira quase instantânea.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documentação dos Censos</span>"
    ]
  },
  {
    "objectID": "6_documentacao.html#documentação-do-censo-disponível-no-censobr",
    "href": "6_documentacao.html#documentação-do-censo-disponível-no-censobr",
    "title": "6  Documentação dos Censos",
    "section": "",
    "text": "Função\nDocumentação\nTipo\nDisponibilidade\n\n\n1960\n70\n80\n91\n2000\n10\n22\n\n\n\n\ndata_dictionary()\nDicionário de variáveis\nMicrodados\nX\nX\nX\nX\nX\nX\nem breve\n\n\nAgregados de setores censitários\n\n\n\n\nX\nX\nem breve\n\n\nquestionnaire()\nQuestionários\nLongo e curto\nX\nX\nX\nX\nX\nX\nX\n\n\ninterview_manual()\nManual do entrevistador\n-\nX\nX\nX\nX\nX\nX\nX",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documentação dos Censos</span>"
    ]
  },
  {
    "objectID": "6_documentacao.html#dicionário-de-dados",
    "href": "6_documentacao.html#dicionário-de-dados",
    "title": "6  Documentação dos Censos",
    "section": "6.2 Dicionário de dados",
    "text": "6.2 Dicionário de dados\nA função data_dictionary() carrega o dicionário de variáveis, apontando a definição de cada variável e o significado de suas categorias no caso de variáveis categóricas. Atualmente, a função abrange os dicionários dos microdados da amostra para todos os censos brasileiros desde 1970: c(1970, 1980, 1991, 2000 e 2010). Além disso, a função também inclui os dicionários dos dados do universo agregados em setores censitário para os anos 2000 e 2010.\n\nlibrary(censobr)\n\n# dicionário de variáveis de pessoas (microdados da amostra)\ndata_dictionary(year = 2010, \n                dataset = 'population')\n\n# dicionário de variáveis de domicílios (microdados da amostra)\ndata_dictionary(year = 2010, \n                dataset = 'households')\n\n\n# dicionário de variáveis de setores censitários (agregados do universo)\ndata_dictionary(year = 2010, \n                dataset = 'tracts')",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documentação dos Censos</span>"
    ]
  },
  {
    "objectID": "6_documentacao.html#questionários",
    "href": "6_documentacao.html#questionários",
    "title": "6  Documentação dos Censos",
    "section": "6.3 Questionários",
    "text": "6.3 Questionários\nCom frequência, é importante se entender a estrutura e fluxo do questionário utilizado em pesquisas de coleta de dados. A função questionnaire() inclui os questionários utilizados na coleta de dados de todos os censos brasileiros desde 1960.\nAlém de passar o parâmetro year, o usuário precisa indicar o tipo de questionário de interesse, se o questionário curto do universo (type = 'short') ou o questionário longo utilizado na pesquisa amostra (type = 'long').\n\n# questionário curto da pesquisa do universo\nquestionnaire(year = 2010, \n              type = 'short')\n\n# questionário longo da pesquisa amostral\nquestionnaire(year = 2010, \n              type = 'long')",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documentação dos Censos</span>"
    ]
  },
  {
    "objectID": "6_documentacao.html#manual-do-entrevistador",
    "href": "6_documentacao.html#manual-do-entrevistador",
    "title": "6  Documentação dos Censos",
    "section": "6.4 Manual do entrevistador",
    "text": "6.4 Manual do entrevistador\nPor fim, a função interview_manual() faz o download e abre no navegador o “Manual do Recenseador”, ou seja, o manual de instruções para os recenseadores do IBGE sobre como coletar os dados do censo. Estão disponíveis os manuais de todos os censos desde 1970.\n\n# Censo de 2010\ninterview_manual(year = 2010)\n\n# Censo de 1970\ninterview_manual(year = 1970)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Documentação dos Censos</span>"
    ]
  }
]